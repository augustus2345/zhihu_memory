



声明：本篇内容基于王道的教学视频。

## 第一章 计算机系统概述

*“较简单，不做过多赘述，后面会详细学到”*

### 第一节 计算机系统层次结构

1.计算机系统的基本组成：硬件+软件

2.计算机硬件的基本组成：运算器+存储器+控制器+输入设备+输出设备

3.系统软件和应用软件



| 系统软件 | 操作系统、数据库管理系统、语言处理程序、分布式软件系统、网络软件系统、标准库语言、服务性程序 |
| 应用软件 | 科学计算类程序、工程设计类程序、数据统计与处理程序 |

4.（易考）翻译程序：



| 汇编程序（汇编器） | 将汇编语言程序翻译成机器语言程序 |
| 解释程序（解释器） | 将源程序翻译成机器指令并立即执行 |
| 编译程序（编译器） | 将高级语言翻译城机器语言或汇编语言 |

### 第二节 计算机性能指标

* **吞吐量**：表征一台计算机在某一时间间隔内能够处理的信息量。
* **响应时间**：表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量。
* **利用率**：在给定的时间间隔系统被实际使用的时间所占的比率，用百分比表示。
* **处理机字长**：指处理机运算器中一次能够完成二进制数运算的位数，如 32 位、64 位。
* **总线宽度**：一般指 CPU 中运算器与存储器之间进行互连的内部总线二进制位数。
* **存储器容量**：存储器中所有存储单元的总数目，通常用 KB、MB、GB、TB 来表示。公式一般是：位数×个数

（MAR×MDR）

* **存储器带宽**：单位时间内从存储器读出的二进制数信息量，一般用字节数/秒表示。
* **主频/时钟周期**：CPU 的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟度量单位是 MHz、GHz

主频的倒数称为 CPU 时钟周期（T），T=1/f，度量单位是 μs、ns。

K= 10^3 ，M= 10^{6} ，G= 10^9 

易错：时钟频率的提高，不能保证CPU执行速度又同倍速的提高，有时候还会减慢。

* **CPU 执行时间**：表示 CPU 执行一般程序所占用的 CPU 时间，可用下式计算：

CPU 执行时间 = CPU 时钟周期数 * CPU 时钟周期

* **CPI**：执行一条指令所需的平均时钟周期数。用下式计算：

CPI = 执行某段程序所需的 CPU 时钟周期数 / 程序包含的指令条数

* **MIPS**：（Million Instructions Per Second）的缩写，表示平均每秒执行多少百万条定点指令数，用下式计算：

MIPS = 指令数 / （程序执行时间 * 10^6）

* **FLOPS**：（Floating-point Operations Per Second）的缩写，表示每秒执行浮点操作的次数，用来衡量机器浮点操作的性能。用下式计算：FLOPS = 程序中的浮点操作次数 / 程序执行时间（s）

### 题目总结：

①对于**高级**语言程序员来说，浮点数格式、乘法指令、数据如何在运算器中运算时透明的。对于**汇编语言**程序员，指令格式，机器构造，数据格式则不是透明的。

②在CPU中，IR、MAR、MDR对各类程序员都是透明的。

③机器字长，指令字长，存储字长

机器字长也称字长——是计算机直接处理二进制数据的位数，机器字长一半等于内部寄存器的大小，它决定了计算机的运算精度。

指令字长——一个指令中包含的二进制代码的位数。

存储字长——一个存储单元中二进制代码的长度。

指令字长一般是存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取值周期为机器周期的2倍；若指令字长等于存储字长，则取值周期等于机器周期。

  


## 第二章 数据的表示和运算

一、无符号整数的表示和运算

Ⅰ、无符号整数的加法：从最低位开始，按位相加，并往更高位进位。

Ⅱ、”被减数“不变，”减数“**全部按位取反**，末位+1，**减法变加法。**

二、带符号整数的表示和运算

带符号的整数表示：原码、补码、反码

※带符号的整数运算可以用原码吗？

用原码的话符号位不能参与运算，需要设计复杂的硬件电路才能处理，贵。

这时候就可以利用补码来进行带符号的整数运算。

①涉及原码和补码的转化。

正数：原码->补码，不变

负数：原码->补码，除符号位外，各位取反，末位+1

Ⅰ、补码的加法

![[v2-e9d73f22bbb9bd56cd52788979fcff57_b.jpg]]
()

从最低位开始，然后按位相加，并往高位进位。算出来的结果，转回原码，就可以得到正值。

补充：补码->原码：类似，除符号位外，各位取反，末位+1

  


Ⅱ、补码的减法

※加法电路造价便宜，减法电路造价昂贵，若将减法变为加法，更加economize。

* 那我们知道了”减数“的补码，那如何求得”减数“负值的补码呢？

补码**全部位**取反，末位+1（易错这里是全部位取反，而带符号位的负数，是除符号位外，各位取反）

其实啊，这里的运算的逻辑结构和无符号的减法运算是一样的，通用一套电路，省钱！

  


三、原码、反码和补码的特性对比



| 8bit | 合法的表示范围 | 最大的数 | 最小的数 | 真值0的表示 |
| --- | --- | --- | --- | --- |
| 带符号原码 | -127~127 | 127 | -127 | +0=00000000-0=10000000 |
| 带符号反码 | -127~127 | 127 | -127 | +0=00000000-0=11111111 |
| 带符号补码 | -128~127 | 127 | -128 | -/+0=00000000只有这一种 |
| 无符号整数 | 0~255 | 255 | 0 | 00000000 |
| 带符号移码 | -128~127 | 127 | -128 | 0=10000000只有这一种 |

原码和反码的合法表示范围完全相同，而且都有两种表示真值0的方法。

补码的合法表示范围多一个负数，原因就是只有一种0的表示方法，因为-0的补码就是00000000

![[v2-5599be316c1aae1b8618fa0cde826632_b.jpg]]
()

  


四、移码，定点小数

移码：在补码的基础上符号位取反。且移码只能表示整数。表示范围和补码相同。

移码的作用：*移码的作用就是方便计算机比较两个数数值的大小。*

定点小数的编码表示：原码、反码、补码。

运算规则和整数的运算规则一模一样。

  


五、电路的基本原理和加法器设计

Ⅰ、补码/无符号整数加减法运算器

![[v2-ea35ee2801583ba73372d324e077841d_b.jpg]]
()

减法运算过程：

①首先Sub信号置为1；

②多路选择器的值为1，Y（减数）经过非门，都取反；

③cin来自低位加1；

Ⅱ、标志位生成

①进位标志CF (Carry Flag)只对无符号运算有意义  
当运算结果的最高有效位有进位（加法）或借位（减法）时，进位标志置1，

即CF = 1；否则CF= 0。

49H + 6DH＝B6H，　没有进位：CF = 0

BBH + 6AH＝（1）25H，有进位：CF = 1  
  
②零标志ZF (Zero Flag)  
若运算结果为0，则ZF = 1；否则ZF = 0

49H + 6DH＝B6H，结果不是零：ZF = 0

75H + 8BH＝（1）00H，结果是零：ZF = 1  
  
③符号标志SF (Sign Flag)只对有符号运算有意义  
运算结果最高位为1，则SF = 1；否则SF = 0

49H + 6DH＝B6H=10110110B，SF=1

④溢出标志OF (Overflow Flag)只对有符号运算有意义  
若算术运算的结果有溢出，则OF＝1；否则 OF＝0

49H + 6DH ＝B6H，产生溢出：OF = 1

75H + 8BH ＝（1）26H，没有溢出：OF = 0

进位CF和溢出OF位有什么区别呢？

进位标志表示无符号数运算结果是否超出范围，运算结果仍然正确，对有符号位加减法无意义。

溢出标志表示有符号数运算结果是否超出范围，运算结果已经不正确，对无符号加减无意义。

溢出的判断判断运算结果是否溢出有一个简单的规则：

只有当两个相同符号数相加（包括不同符号数相减），而运算结果的符号与原数据符号相反时，产生溢出；因为，此时的运算结果显然不正确其他情况下，则不会产生溢出

1.当两个符号相同的数相加，结果的符号与之相反，则OF=1,否则OF=0.

2.当两个符号不同的数相减，结果的符号与减数相同，则OF=1,否则OF=0.

  


六、定点数的移位运算

* 左移1位相当于×2，右移1位相当于÷2
* 原码：符号位不参与移位。左移，右移都补0
* 反码：符号位不参与移位。**若反码是负数补1；若反码是正数补0**
* 补码：符号位不参与移位。**若补码是负数左移低位补0，右移高位补1；若补码是正数，左移右移都补0**

七、原码补码的乘法除法运算

Ⅰ、原码的一位乘法

符号位通过异或确定；数值部分通过被乘数和乘数绝对值的n轮加法、移位完成，根据当前乘数中参与运算的位确定（ACC）加什么。若当运算位=1，则（ACC）+[|x|],若为0，则(ACC)+1。每轮加法完成后，ACC,MQ的内容统一逻辑右移。

![[v2-391e106f8411d22834924628fce767cc_b.jpg]]
()

先ACC初始化。x置于通用寄存器中，y置于MQ。

  


Ⅱ、补码的一位乘法

原码一位乘法和补码一位乘法的不同点



| 原码一位乘法 | 补码一位乘法 |
| --- | --- |
| 进行n轮的加法、移位 | 进行n轮加法，移位，最后再多来一次加法 |
| 每次加法相加，只有两种情况+0或加x | 每次加法加有三种情况，0或+x或+[-x] |
| 每次移位都是逻辑右移，补1 | 每次都是补码的右移，正数右移补0，负数右移补1 |
| 符号位不参与运算 | 符号位参与运算 |

* 会添加一位辅助位
* 辅助位-MQ中“最低位”=1时，(ACC)+[X)]补
* 辅助位-MQ中“最低位”=0时，(ACC)+0
* 辅助位-MQ中“最低位”=-1时，(ACC)+[-X]补

![[v2-2893d67d4084b3376497e97a8eb18f31_b.jpg]]
()

  


八、C语言类型转换和数据存储排列

* C语言中定点整数是用”补码“存储的。
* 无符号数转为有符号数：不改变数据内容，改变解释方式。
* 长整数变为短整数：高位截断，保留低位。
* 短整数变长整数：若为有符号数，在符号位和数值位添1，若为无符号，直接在高位添0。
* 大小端模式：大端方式便于人类阅读；小段方式便于机器处理，因为机器最先读入的就是最应被处理的数据。
* 边界对齐：假设存储字长为32位，则1个字=32bit,半字=16bit。每次访存只能读/写1个字。若采用边界对齐的方式，则访问一个字/半字都需要一次访存，虽然会造成一点点的空间浪费。采用不对齐的方式，对空间利用率高，但是可能会涉及到两次访存时间大大增加。

九、浮点数的表示和运算

Ⅰ、概念：之前我们学习了定点数，其中「定点」指的是约定小数点位置固定不变。那浮点数的「浮点」就是指，其小数点的位置是可以是**漂浮不定**的。

Ⅱ、表示：阶符表示的是阶码正负，尾数的数符表示的是尾数正负。

阶码：常用补码或移码表示的定点整数，反映表示范围。

尾数：常用原码或补码表示的定点小数，反映精度。

  


![[v2-a33b270ce33f2c1941135149253f12c3_b.jpg]]
()

Ⅲ、**规格化：规定尾数的最高位必须是有效位**。

①”有效位“又分两种情况。分为尾数是补码表示还是原码表示

原码表示的尾数视格化：**尾数的最高数值位必须是1**

补码表示的尾数规格化：**尾数最高数值位必须和尾数符号位相反**

②左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码减1。


> b= 2^2\times(+0.01001)=2^1\times(+0.10010) #尾数最高位为0，左规

右规：当**浮点数运算的结果尾数出现溢出（双符号位为01或10）时**，将尾数算数右移一位，阶码加1。

![[v2-752d22af369fc6e9b81a2d0aaaea880f_b.jpg]]
()

采用双符号位，当发生溢出时（双符号位为01或10），可以采用右规，更高位的符号位是正确的符号位。

③虽然浮点数的范围和精度也有限，但其范围和精度都已非常之大，所以在计算机中，对于小数的表示我们通常会使用浮点数来存储。

![[v2-8acb78c4e63abb8a46248012d48d880d_b.jpg]]
()

十、IEEE 754

背景：在浮点数提出的早期，各个计算机厂商各自制定自己的浮点数规则，导致不同厂商对于同一个数字的浮点数表示各不相同，在计算时还需要先进行转换才能进行计算。后来 IEEE 组织提出了浮点数的标准，统一了浮点数的格式，并规定了单精度浮点数 float 和双精度浮点数 double，从此以后各个计算机厂商统一了浮点数的格式，一直延续至今。

![[v2-c3a75e79d45d887b84a5f25f50b38906_b.jpg]]
()

![[v2-6c230c6c155cc19c71654f99d4cc65b7_b.jpg]]
()

![[v2-d945a91caf4fa11ce472acbc8af7adb6_b.jpg]]
()

十一、浮点数运算（重点）

现代计算机表示数的方法通常都是浮点数了，所以这节很重要。

①对阶：小阶向大阶靠齐，方便计算机对尾数进行处理。

②尾数加减：尾数常规加减。

③规格化：如果尾数加减出现类似0.0099517× 10^{12} 时，需要“左规”；

如果尾数加减出现类似99.517107× 10^{12} 时，需要“右规”。

④舍入：尾数位数有限，若规定只能保留6位有效尾数，则9.9517107× 10^{12} →9.95171× 10^{12} (多余的直接砍掉)或者，9.9517107× 10^{12} →9.95172× 10^{12} （若砍掉分非0，则入1)或者，也可以采用四舍五入的原则，当舍弃位≥5时，高位入1。

⑤判溢出：若规定阶码不能超过两位，则运算后阶码超出范围，则溢出。

如：9.85211× 10^{99} +9.96007× 10^{99} =19.81218× 10^{99} 规格化并用四舍五入的原则保留6位尾数，得1.98122× 10^{100} ,阶码超过两位，溢出。

![[v2-6d338dce25cad304ddea223a2e1c3581_b.jpg]]
()

强制类型转化：

无损：char->int->long->double

float->double

有损：int->float,可能会损失精度

float->int，可能会溢出，也可能会损失精度

## 第三章 存储系统

### 第一节 存储器概述

一、存储器的层次结构

寄存器->Cache->主存->辅存->外存

Cache-主存：解决了主存与CPU速度不匹配的问题。

主存-辅存：实现虚拟存储系统，解决了主存容量不够的问题。

※辅存中的数据要调入到主存才能被CPU访问

二、存储器的分类

Ⅰ、按照存取方式：分为随机存取存储器（RAM），如内存；顺序存取存储器（SAM），如磁带；直接存取存储器（DAM），如磁盘；相联存储器（可按内容访问的存储器，CAM），如快表。

Ⅱ、按信息是否可改：分为读/写存储器和只读存储器（ROM）

Ⅲ、断电后是否消失：分为易失性存储器，如内存、Cache；非易失性存储器，如磁盘、光盘

  


三、存储器的性能指标

1.存储容量：存储字数×字长

2.单位成本：每位价格=总成本/总容量

3.存储速度：数据传输率=数据的宽带/存储周期

存储周期=存取时间+恢复时间

  


### 第二节 主存储器

一、SRAM和DRAM

一个静态RAM，一个动态RAM。动态的用于主存，静态的用于Cache

SRAM和DRAM的差别



| 类型特点 | SRAM | DRAM |
| --- | --- | --- |
| 存储信息 | 触发器 | 电容 |
| 破坏性读出 | 非 | 是 |
| 读出后是否需要重写 | 不用 | 需要 |
| 运行速度 | 快 | 慢 |
| 集成度 | 低 | 高 |
| 发热量 | 大 | 小 |
| 存储成本 | 高 | 低 |
| 是否易失 | 易失 | 易失 |
| 是否需要刷新 | 不需要 | 需要 |
| 作用 | 常用作Cache | 常用作主存 |

二、ROM只读存储器

RAM芯片——易失性，断电后数据消失

ROM芯片——非易失性，断电后数据不会消失

①MROM——掩模式只读存储器：任何人都不可重写

②PROM——可编程只读存储器：写一次后就不可更改

③EPROM——可擦除可编程只读存储器：可进行多次重写，写入时间很长

④Flash Memory——闪速存储器：可进行多次快速擦除重写，但写的速度比读的速度慢

⑤SSD——固态硬盘：可进行多次快速擦除重写，目前个人电脑大都市这种。速度快，功耗低，价格高。

  


### 第三节 主存储器与CPU的连接

一、单块存储器与CPU连接

Ⅰ、连接原理：主存器通过数据总线，地址总线和控制总线与CPU连接。

地址总线的位数决定了可寻址的最大内存空间。

控制总线指出总线周期类型和本次输入输出操作完成的时刻。

![[v2-eb7b6cf42b14d9175b741d581365c965_b.jpg]]
()

主存储器的线路  


二、多块存储器与CPU连接

Ⅰ、位扩展法

原理：CPU的数据线与存储芯片的数据位数不相等，此时必须使用多个存储器件对字长进行扩位。每个存储器的数据线都并行连接在CPU的数据总线上，而地址位数是串行相连。那CPU传一个地址过来，怎么知道是使用哪个存储芯片呢，此时就要WE来控制使用哪个存储芯片。

![[v2-e226ddea6ccd4cc021ac8560cf82e77e_b.jpg]]
()

Ⅱ、字扩展法

原理：当主存储器位数不足，字数足够时，我们会通过位扩展的方法来扩展主存储器，将多个字数相同的存储芯片并联起来，增加位数，并且存储空间是连续的。里面还会涉及译码器，主要功能就是增加控制存储器的个数，如有两位地址线连接了译码器，那么译码器可以控制 2^2 个存储器。

![[v2-02a88dd94b7a0072f1ef0359fe4b63e7_b.jpg]]
()



| 线选法 | 译码片选法 |
| --- | --- |
| n条线n个片选信号 | n条线2的n次方个片选信号 |
| 电路简单 | 电路复杂 |
| 地址不连续（两位举例，00和11的地址用不到） | 地址连续（00和11的地址也都用到了） |

Ⅲ、字位同时扩展

原理：而当字数和位数都不足时，我们会通过字位同时扩展的方法来扩展存储器，将多个字数和位数都相同的存储芯片连接起来，同时增加字数和位数。

Ⅳ、三者比较

字扩展方法只能增加主存储器的容量，存取速度没有提升。而位扩展方法不光可以增加主存储器的容量，同时还可以让多个存储芯片同时工作，同时做读写操作，增加了存取速度。字位同时扩展的方法又可以增加主存储器的容量，又可以让多个存储芯片同时工作，那么是不是只用字位同时扩展这一种方法就可以了呢？任何事情都是有利弊两面性的，在能力增强的同时，他的成本，功耗和体积都会增加，所以我们还是要根据实际的系统需求来判断具体使用的主存储器扩展方法。

Ⅴ、题目总结

【2018统考真题】假定DRAM芯片中存储阵列的行数为r、列数为c,对于一个2K×1位的DRAM芯片，为保证其地址引脚数最少，并尽量减少刷新开销，则r、c的取值分别是()。

解：r是行，c是列，为了保证地址引脚数最少，就要求，行列相差小，并且减少刷新开销，则要求行数越小越好。故最终行数位32，列数位64。

三、多模块存储器

背景：随着CPU的功能不断增强，I/O设备数量不断增多，这也导致了主存的存取速度已成为计算机系统的发展瓶颈。为了解决此问题，除了寻找更高速的原件和采用存储器层次结构外，调整主存的结构也可以提高访存速度，这就涉及到了多模块存储器。

由于取值周期=存取时间+恢复时间。DRAM芯片恢复时间较短，有可能是存取时间的几倍。那怎么半，不能让设备停着吧。那太浪费资源了。

Ⅰ、双端口RAM

顾名思义，就是利用两个端口实现多核CPU存储，需要有两组完全独立的数据线，地址线，控制线。支持两个CPU同时访问。

两个端口可以同时对不同单元的地址中取数据，也可以对同一地址单元中读出数据，但是不行同时对同一单元中写入数据，也不能对同一单元一边读一边写入数据。

解决办法：发出”busy“信号，其中一个CPU的访问端口暂时关闭。

Ⅱ、单体多字存储器

原理：原来每行只存放一个存储字，变为每行存放多个存储字，这样原来一次只能读取一个存储字，变为一次能读取多个存储字，这需要数据总线根数变大。

限制：指令和数据在主存必须是连续存放的。

![[v2-2081a3ed77b1b86bec4cf0e7c0b04b71_b.jpg]]
()

Ⅲ、多体并行存储器（重点）

原理：每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路，地址[寄存器](https://link.zhihu.com/?target=https%3A//so.csdn.net/so/search%3Fq%3D%25E5%25AF%2584%25E5%25AD%2598%25E5%2599%25A8%26spm%3D1001.2101.3001.7020)，和数据寄存器，既能并行工作，又能交叉工作（一个模块进入恢复时间，另一个模块进行存取）。

![[v2-ad7b439961372bdb3c1d340ba39c5d18_b.jpg]]
()

区别：在高位交叉中，由于下一个访问的地址还是在这个存储体上，所以必须等到恢复时间结束后才能继续访问，故不能并行访问。效果也仅仅是扩容。而在低位交叉编制中，下一个访问地址不在同一个存储体上，所以可以交叉访问，不仅扩容还加快了访问速度。当块数m \geq T/r时，能达到最佳存储效率。T为存取周期，r为存取时间。

![[v2-eb9c1f45b40f9101b1f4f4793b4a9404_b.jpg]]
()

  


### 第四节 外部存储器

一、磁盘存储器

优点：存储容量大，价格低，长期保存而不丢失。

缺点：存取速度慢，机械结构复杂，对环境要求高。

磁盘最小的读写单位是一个扇区。

二、固态存储器SSD（新增考点）

优点：读写速度快。若要写的页有数据，则不能写入，需要将块内其他页全部复制到一个新的块中，再写入新的页。

缺点：价格高，一个块被写入多次可能会坏掉（采用平均磨损，对我们来说仍然很耐用）而磁盘不会。

  


### 第五节 高速缓冲存储器（重点）

一、什么是Cache，为什么要引入Cache？

Cache存储器也被称为高速缓冲存储器，位于CPU和主存储器之间。之所以在CPU和主存之间要加cache是因为现代的CPU频率大大提高，内存的发展已经跟不上CPU访存的速度。在2001 – 2005年间，处理器时钟频率以每年55%的速度增长，而主存的增长速度只是7%。**在现在的系统中，处理器需要上百个时钟周期才能从主存中取到数据。如果没有cache，处理器在等待数据的大部分时间内将会停滞不动**。

二、原理

采用了程序访问的时间局部性原理和空间局部性原理

时间局部性：**如果一个数据现在被访问了，那么以后很有可能也会被访问**

空间局部性：**如果一个数据现在被访问了，那么它周围的数据在以后可能也会被访问**

三、多级Cache的由来？

cache分为L1，L2，L3甚至L4等多级。为什么不能把L1的容量做大，不要其它的cache了？原因在于性能/功耗/面积（PPA）权衡考虑。L1 cache一般工作在CPU的时钟频率，要求的就是够快，可以在2-4时钟周期内取到数据。L2 cache相对来说是为提供更大的容量而优化的。虽然L1和L2往往都是SRAM，但构成存储单元的晶体管并不一样。L1是为了更快的速度访问而优化过的，它用了更多/更复杂/更大的晶体管，从而更加昂贵和更加耗电；L2相对来说是为提供更大的容量优化的，用了更少/更简单的晶体管，从而相对便宜和省电。在有一些CPU设计中，会用DRAM实现大容量的L3 cache。

四、如何区分Cache和主存的数据块对应关系？

每次被访问的主存块，一定会被立即调入Cache，而且是以块为单位进行调入。

![[v2-0f70d191adbfc39a630028975a91c9e9_b.jpg]]
()

那是采用什么方式将主存块号调入到Cache呢？有三种方式

①全相联映射——主存块可以放在Cache的任意位置。

**那它是如何来访问主存的呢？**

![[v2-dac5bfcf4320627d7382756d787e9282_b.jpg]]
()

对以上图只要能看懂，对于全相联映射就没什么问题了。做几点说明，CPU在访问主存时，会先对比Cache所有块中的标记Tag，Tag就是在主存中的主存块号，占22位。

②直接映射——每个主存块只能放在一个特定的位置。Cache块号=主存块号%Cache块总数

![[v2-3281b09fe554d06d1f0a7c3582a5a65a_b.jpg]]
()

做以下几点说明

* 相对于全相联映射，直接映射对**Tag进行了优化**，因为主存块号最后三位地址就是Cache中的位置，所以将主存块号其余位作为标记即可。
* 若Cache总块数= 2^n ,则主存块号末尾n位直接反映它在Cache的位置，所以将主存块号其余位作为标志位即可。

  


③组相联映射——Cache块分为若干组，每个主存块可以放到特定分组中的任意一个位置。组号=主存块号%分组数

![[v2-472544d30167b0d77932054da9636e3d_b.jpg]]
()

做以下几点说明

* 相对于全相联映射，直接映射对**Tag进行了优化**，因为主存块号最后两位地址就是Cache中的位置，所以将主存块号其余位作为标记即可。
* 一个组内有几个Cache块就成为几路相联映射

④三种映射方法对比总结



|  | 全相联 | 直接 | 组相联 |
| --- | --- | --- | --- |
| 特点 | 任意位置 | 特定位置 | 分组中的任意位置 |
| 主存地址结构 | 标记+块内地址 | 标记+行号+块内地址 | 标记+组号+块内地址 |
| 优点 | Cache存储空间利用充分 | 对任意地址，执行对比一个Tag，速度快 | 折中办法 |
| 缺点 | 可以会对比所有行的标记，速度慢 | Cache空间利用不充分 | / |

五、Cache很小，而主存很大，如果Cache满了，是利用了什么替换算法？

替换条件：对于全相联映射，需要在全局中选择替换哪一块，对于直接映射，若非空，则直接替换，对于组相联，组内满了，则在组内选择替换哪一块。

Ⅰ、随机算法(RAND)

随机，随便，随意，换哪一个都行。实现简单，但完全没有考虑局部性原理，命中率低，实际效果很不稳定。

可能会导致，换出的块，下一次又需要访问。就会多次访问内存块。导致抖动现象。

Ⅱ、先进先出算法(FIFO)

替换最先进入的块。同样实现简单，但仍然没有考虑到局部性原理，最先被调入Cache块可能是被访问最频繁的。

Ⅲ、近期最少使用(LRU)

为每个Cache块设置一个”计数器“，用于记录每个Cache块多久没有被访问了。然后替换”计数器“值最大的。

* 计数器的位数=Cache块的总数= 2^n ，只需要n位，且Cache装满后所有计数器的值一定不重复。
* 基于局部性原理，近期被访问的主存块，未来可能仍会被使用，LRU算法实际运行效果优秀。
* 若频繁访问的主存块数量>Cache行的数量，则有可能发生”抖动“

Ⅳ、最近不经常使用(LFU)

为每个Cache设置一个”计数器“，用于记录Cache被访问过几次，然后替换”计数器“值最小的（访问次数最少的）

曾经被经常访问的主存块不一定在未来会被用到。并没有很好的遵循局部性原理，因此实际运行效果不如LRU。

六、Cache写策略——CPU修改了Cache中的数据副本，如何确保主存中数据母本一致性？

Ⅰ、写命中——写入的时候，在Cache中

①回写法：当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当次块被换出时才写回主存。减少了访存次数，但存在数据不一致的隐患。

被换出时，看”脏位“是否知道是否被修改。

②全写法：当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲。访存次数增加，速度变慢，但是能保证数据的一致性。无脏位。

Ⅱ、写不命中——写入的时候，不在Cache中

①写分配法——当CPU对Cache不命中时，把主存中的块调入Cache，在Cache中修改。通常搭配**回写法**使用，改完后要被换出，才在主存中修改。

②非写分配法——当CPU对Cache写不命中时，只写入主存，不调入Cache，搭配全写法使用。

  


### 第六节 虚拟存储器

虚拟存储器：在操作系统的管理下，只把当前需要的部分数据调入主存，暂不需要的部分留在辅存中。在用户看来，似乎获得了一个超大的主存。（虚拟性）

一、页式虚拟存储器

背景：CPU执行的机器指令中，使用的是”逻辑地址“，因此需要通过”页表“将逻辑地址转为物理地址。

一个程序在逻辑上被分为若干个大小相等的”页面“，”页面“大小与”块“的大小相同。每个页面可以离散的存放在不同主存块中。

页表的作用：记录了每个逻辑页面存放在哪个主存块中。

无快表：

![[v2-21fdfa251e8eb343e068c88d0b9f29aa_b.jpg]]
()

* 逻辑地址=逻辑页号+页内地址
* 物理地址=主存块号+页内地址

  


增加快表（存放在Cache中，先访问快表，若未命中，则去访问主存中的慢表）

![[v2-50e00a292c05bed40918aa296e075da5_b.jpg]]
()

* 快表查询速度很快，若快表中无，则会去慢表中查找，会把相应的内容存入快表中

**清楚整个查找流程**

![[v2-b465572e1822271d789a22a4df05abc5_b.jpg]]
()

二、段式虚拟存储（按功能拆分成大小不同的模块）

按照功能模块拆分不同的模块大小。

虚拟地址：段号+段内地址

优点：段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护。

缺点：段的长度可变，分配空间不便，容易留下碎片，不好利用，造成浪费。

三、段页式虚拟存储

把程序按逻辑结构分段，每段在分固定大小的页，主存空间也划分为大小相等的页，每个程序对应一个段表，每段对应一个页表。

虚拟地址：段号+段内地址+页内地址

优点是兼具段式和页式的优点缺点是需要查两次表，系统开销较大。

四、虚拟存储器与Cache的比较



| Cache | 虚拟存储器 |
| --- | --- |
| 解决CPU与主存速度不匹配的问题 | 解决主存容量的问题 |
| 全由硬件组成，对所有程序员透明 | 由OS和硬件组成，逻辑上存储器对系统程序员不透明 |
| 不命中影响小 | 不命中影响大 |
| 不命中时，主存直接与CPU通信 | 不命中时，不能直接和CPU通信，要先硬盘调入主存 |

### 题目总结：

【2015统考真题】假定主存地址为32位，按字节编址，主存和Cache之间采用直接映射方式，主存块大小为4个字，每字32位，采用回写方式，则能存放4K字数据的Cache的总容量的位数至少是()

* Cache的容量分为两个部分一个是数据存储容量+标记阵列容量
* 标记阵列中一定包含有效位和标记位，若为回写法，则还存在一位的”脏位“，若为LRU、LFU替换算法，则还存在替换算法位（计数器）位数为 log\_2^n ,n为Cache的个数。
* 本题按照字节编址，则块内地址占4位，采用直接映射方法中的标志位为32-4-10=18，Tag=18。
* 采用回写法，有一位脏位，故最终标记项有18+1+1=20
* 标记阵列容量为 2^{10} ×20=20K，数据储存容量为4K×32=128K，故总的为148K。

## 第四章 指令系统

### 第一节 指令格式

指令概念：又称机器指令，是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。

一条指令就是机器语言的一个语句，一条指令通常要包括操作码和地址码两部分：操作码主要指明用户干什么，地址码主要指明对谁操作。

一、指令分类

按操作数个数分：

Ⅰ、零地址指令：不需要操作数，如空操作、停机、关中断等指令

Ⅱ、一地址指令：只需要单个操作数，如自增，自减，取反，求补，需要两个操作数，但其中一个隐含在某个寄存器中

Ⅲ、二地址指令：常用于两个操作数的算术运算、逻辑运算相关指令。

完成一条指令需要访存四次，分别为取值，读第一个操作数，读第二个操作数，写回第一个操作数。

Ⅳ、三地址指令：常用于两个操作数的计算，结果放在第三个地址中。

完成一条指令需要访存四次，分别为取值，读读一个操作数，读第二个操作数，写到第三个操作数。

※若指令长度不变，地址码数量越多，寻址能力就越差

按指令长度是机器指令的多少倍分：

Ⅰ、半长指令：是机器指令长度一半

Ⅱ、单字长指令：与机器指令长度一样

Ⅲ、双字长指令：是机器指令长度两倍

二、扩展操作码指令格式（考点：会设计指令系统）

概念：指令是定长的，但是操作码的长度可变。

通常情况下，使用频率高的指令使用短的操作码，减少指令译码和分析的时间。而使用频率低的指令使用长的操作码

![[v2-be3a17c0e449bcb3b40d118da740ade5_b.jpg]]
()

定长指令和扩展操作码的比较



|  | 定长操作码 | 扩展操作码 |
| --- | --- | --- |
| 优点 | 硬件设计简单，识别速度快 | 在指令长度限制下仍有丰富指令 |
| 缺点 | 指令难以增加，不灵活 | 增加指令译码和分析难度，速度慢 |

【2017统考真题】某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令29条、二地址指令107条，每个地址字段为6位，则指令字长至少应该是()。

解答：三地址29条需要的位数是5位，多出3位，而107条需要6位。故总共5+6+12=23，因为按照字节编址，所以最少需要24位。

### 第二节 寻址方式（重点）

一、指令寻址（由PC指出）

Ⅰ、顺序寻址

PC+”1“，这里的1指指令字长，每次取值结束后PC会+1

Ⅱ、跳跃寻址

执行转移类指令导致的PC值改变

二、数据寻址（由本条指令的地址码指明真实地址）

非偏移指令



| 寻址方式 | 有效地址 | 优点 | 缺点 | 访存次数（指令执行期间） |
| 直接寻址 | 操作数的真实地址 | 简单 | 限制寻址范围 | 1 |
| 间接寻址 | 操作数地址的地址 | 可扩大寻址范围 | 指令在执行阶段要多次访存 | 最少2次 |
| 寄存器寻址 | 寄存器的地址 | 不访问主存，速度快 | 寄存器昂贵 | 0 |
| 寄存器间接寻址 | 寄存器地址，内部是操作数主存地址 | 与一般的间址快 | 但执行仍然会访存 | 1 |
| 隐含寻址 | 指令中隐含操作数地址 | 有利于缩短指令字长 | 需要增加存储操作数的硬件 | 0 |
| 立即寻址 | 就是操作数本身 | 最快 | 限制操作数范围 | 0 |

  


偏移寻址（重中之重）

指令执行过程中，都会在将运算结果放入主存中，涉及一次访存。

Ⅰ、基址寻址

将CPU中基址寄存器(BR)/通用寄存器的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA=(BR)+A

![[v2-c426e479dc932fe12028a48168538710_b.jpg]]
()

※采用通用寄存器作为基址寄存器 R\_0 的位数，根据通用寄存器的总数判断，程序运行前，CPU将BR的值修改为该程序的起始地址。

* 基址寄存器是面向操作系统的，其内容由**操作系统或管理程序**确定。用户无法修改，在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。
* 当采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由**操作系统**确定。
* 优点：可扩大寻址范围（基址寄存器的位数大于形式地址A的位数）

Ⅱ、变址寻址

有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和，即EA= (IX)+A，其中IX可为变址寄存器（专用），也可用通用寄存器作为变址寄存器 。

![[v2-6df574e85878849521f251069abee20a_b.jpg]]
()

* 变址寄存器是面向用户的，在执行过程中，变址寄存器的内容可由用户改变（IX作为偏移量），形式地址A不变（作为基地址）。刚好与基址寻址相反。
* 在针对**数组处理**过程中，不断改变IX的值，便很容易形成数组中任一数据的地址，特别适合**编制循环程序**。
* 基址变址复合执行。EA=(IX)+(BR)+A。

Ⅲ、相对寻址

相对寻址：把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA=(PC)+A，其中A是相对于PC所指地址的位移量，可正可负，补码表示 。

![[v2-f24ae7c93c806bdd93b31154b7564dff_b.jpg]]
()

* 优点：这段代码在程序内浮动时不用更改跳转指令的地址码
* 相对寻址广泛应用于转移指令
* 注意：对于JMP A转移指令，当从CPU中取出一字节时，会自动执行PC+1。若指令的地址为X，且占2B，在取出该指令后，会自定跳转到X+2+A。

堆栈寻址

操作数存放在堆栈中，隐含使用堆栈指针作为操作数地址。

* 硬堆栈是将寄存器作为栈，成本很高；软堆栈是将主存作为栈，成本低。
* 硬堆栈不访存，软堆栈访存一次

### 第三节 高级语言程序与机器级代码之间的对应

一、基本概念

* 对操作数的操作地址只涉及三种：寄存器到寄存器，主存到寄存器，立即数到寄存器。
* dword 32bit ；word 16bit ；byte 8bit
* 通用寄存器 eax ebx ecx edx 变址寄存器 esi edi 堆栈寄存器 ebp esp。

二、选择结构语句的机器级表示



| je | jump when equal, |
| jne | jump when not equal, |
| jg | jump when greater, |
| jge | jump when greater or equal |
| jl | jump when less |
| jle | jump when less or equal |

![[v2-4b5d24029f1096007c35dcb29e34a7a9_b.jpg]]
()

例如


> cmp eax ,ebx #比较寄存器eax和ebx里的值  
> jg NEXT #若eax>ebx，则跳转到NEXT

  


三、循环结构语句的机器级表示

用条件指令实现循环

![[v2-96caf8f78b1b6a289b88f4840799eb6e_b.jpg]]
()

用loop指令实现循环

![[v2-5fa788a175c098bb2283fe9ef3808155_b.jpg]]
()

就是将”某些处理“封装到了Looptop内，使得代码更加简洁。

四、CISC和RISC



| 对比项目 | CISC | RISC |
| --- | --- | --- |
| 指令系统 | 复杂，庞大 | 简单，精简 |
| 指令数目 | 一般大于200条 | 一般小于100条 |
| 指令字长 | 不固定 | 定长 |
| 可访存指令 | 没有限制 | 只有Load/Store指令 |
| 各种指令执行时间 | 相差较大 | 绝大多数在一个周期内完成 |
| 各指令使用频率 | 有的常用，有点不常用 | 一般都常用 |
| 通用寄存器的数量 | 较少 | 多 |
| 控制方式 | 绝大多数为微程序控制 | 绝大多数为组合逻辑控制 |
| 指令流水线 | 可以通过一定方式实现 | 必须实现 |

## 第五章 中央处理器

### 第一节 CPU

一、CPU的结构

CPU由运算器和控制器组成。

![[v2-4b8e102d396ad3c46994b1db74f31df7_b.jpg]]
()

二、CPU的功能

指令控制、操作控制、时间控制、数据加工、中断处理。

运算器的功能：对数据加工

控制器的功能：取指令、分析指令、执行指令

  


### 第二节 指令执行过程

在指令周期中，包含了：取指周期，在取指周期后需要判断是否有间址周期，如果没有就进入到执行周期，在执行周期后又需要判断是否有中断程序，如果有就响应中断并保存断点生成中断服务程序入口；如果没有就进入下一个取指周期。

![[v2-b654a0a7ae41e17adb83c4b78a878c44_b.jpg]]
()


> 四个周期都有CPU访存操作，只是访存目的不同。取值周期是取指令；间址周期是取有效地址；执行周期是为了取操作数；中断周期是为了保存程序断点。

指令周期常常有若干个机器周期，机器周期里面又包含若干个时钟周期。每个指令周期内的机器周期可以不同，机器周期内的时钟周期也可以不同。时钟周期是CPU操作的最基本单位。

![[v2-317924ae7f3d6f8258e5a311020eee89_b.jpg]]
()

  


一、取值周期

取指周期：取指周期的任务是根据PC中的内容从主存中取出指令代码并存放在IR中。而PC中存放的是指令的地址，根据这个地址从内存单元取出的是指令，并放在指令寄存器IR中，取指令的同时，PC加1。

![[v2-2fa4b95ed36149c68e6bca747d752918_b.jpg]]
()

  


  


二、间址周期

间址周期：间址周期的任务是取操作数有效地址，以一次间址为例，将指令中的地址码送到MAR并送至地址总线，此后CU向存储器发读命令，以获取有效地址并存至MDR。

![[v2-bf45033e4d627d05e098b4702a07adfa_b.jpg]]
()

三、执行周期

执行周期：执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。

指令执行方案：



| 单指令周期 | 所有指令选用相同的执行时间（取决于最长指令执行时间），指令间串行，但原本只需要很短时间完成指令也分配了很长时间，降低整个系统运行速度 |
| 多指令周期 | 对不同指令选用不同的执行时间，需要更复杂的硬件设计，指令间是串行 |
| 流水线 | 在每个时钟周期让多个指令同时运行，指令间是并行 |

四、中断周期

中断周期：中断周期的任务是处理中断请求。假设程序断点存入堆栈中，并用SP指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据。

![[v2-0a9db9ebd720e62143d040e3c48eafb1_b.jpg]]
()

  


### 第三节 数据通路的功能和基本结构

一、数据通路的基本结构

Ⅰ：CPU内部单总线方式。将所有寄存器的输入端和输出端都连接在一条公共通路上。易发生冲突。

Ⅱ：双总线/多总线方式。多个总线上传不同的数据，提高效率。

Ⅲ：专用数据通路方式。专门给某些部件设计通路。性能很高但是硬件量大。

说明：

①对于单总线的连接方式来说，ALU只能有一端与总线相连，因为两端相连就必会发生冲突。所以另一段要设计一个暂存器，先把数据放入暂存器，暂存器再与总线相连。

②单周期就是指令在一个周期内完成，这是需要与多总线结构配合。才能使各个部件的数据传递。因为单总线一个周期内只能传递一个数据，所以指令不可能在一个周期内完成。



| 内部总线 | 是指同一部件，如CPU内部连接各个寄存器及运算部件之间的总线 |
| 系统总线 | 指同一台计算机的各部件，如CPU，主存，I/O之间连接的总线 |

  


### 第四节 控制器的功能和工作原理

一、硬布线控制器

*多提一嘴，一定要看看王道视频是如何设计出组合逻辑图的，我保证看完一定会有颠覆性的收获。*

**根据指令操作码、目前的机器周期、节拍信号、机器状态条件，即可确定现在这个节拍应该发出哪些”微命令“**

![[v2-3af7e2c234438b972cecf3ef0e2cce32_b.jpg]]
()

硬布线控制器的特点：

* 指令越多，设计和实现就越复杂（逻辑图很复杂），因此一般使用RISC。
* 如果扩充一条新的指令，则控制器的设计就需要大改，因此扩充指令较为困难。
* 由于使用存纯硬件实现控制，因此执行速度很快。

二、微程序控制器（重难点）

要求：会基本概念微命令与微操作，微指令与微周期，主存储器与控制存储器，程序与微程序，MAR与CMAR，IR与CMDR。还会一些基本结构，比如为地址形成部件，微地址寄存器CMAR，微指令寄存器CMDR,控制存储器CM。

* **微命令**：控制器部件向执行部件发出的控制命令，是构成控制序列的最小单位，例如打开或者关闭控制门的电位信号。是各部件完成某个基本微操作的命令
* **微操作**：执行部件接受微命令后所进行的操作，和微操作是一一对应的。 （实际上，微命令是微操作的控制信号，微操作是微命令的执行过程，微操作是执行部件中最基本的操作）
* **微指令**：若干微命令的集合，存放在一个控制存储器中，而**存放微指令的控制存储器的单元成为微地址**。在同一CPU周期内，**并行执行的一组微命令，存储在控制存储器上面，称为一条微指令**。
* **微周期**：从读取一条微指令，到执行执行完毕所需要的时间称为微周期。
* **控制存储器**：**主存储器**，主要用来存放程序和数据，位于CPU的外部，使用的是RAM。而**控制存储器，则主要用于存储微程序，位于CPU内部，采用的是ROM**。
* **微程序**：实现一条机器指令功能的微指令序列。
* **程序与微程序**：程序由机器指令构成，编写好以后放到主存中运行，可以改写。而微程序由微指令构成，事先编写好在CM（控制存储器）中，一般是不可改写的。微程序的作用就是实现一条对应的机器指令。
* 微程序>微指令>微命令=微操作是微命令的执行过程。

![[v2-e226b0670a4abe69cbc4e0fa00cc9043_b.jpg]]
()

秒懂哦* 一台计算机可以分为控制部件和执行部件。其中控制部件有指令寄存器，程序计数器，操作控制器，执行部件有运算器，存储器，外围设备，状态条件寄存器。
* 汇编程序员可见的寄存器有基址寄存器和状态/标志寄存器，程序计数器PC及通用寄存器。而MAR,MDR,IR,是CPU内部寄存器，汇编程序员不可见，微指令相关的汇编程序员也不可见。

水平型微指令的编码方式（重点会考）

**①字段直接编码**对于直接编码的方式最大的好处就是能够并行微操作，缩短了微命令的字段长度。有个题能很好的解释这其中的原因。某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码方式，共有33歌微命令，构成5个互斥类，分别包含7，3，12，5和6个微命令，则操作控制字段至少有几位？

**每个互斥类要留1个状态位不操作**，故为8，4，13，6，7个微命令。则需要3，2，4，3，3位共15位控制字段，而直接控制法要33位。很明显的缩减操作字段位数。

优点明显，缺点也明显啊。增加了译码，执行时间会增长，而却增大成本。

②**直接编码**就是每个控制字段位，就代表一个微命令，优点就是快，电力嘎嘎简单。但是若微命令要是多达几百条。那不是要几百位了。因此指令位数太长。

③某带有中断的指令系统有101中操作，采用微程序控制方式，存储器中相应最少有103个微程序。

**要加上取值操作和终端操作，**若有n条操作，则有**n+2个微程序**

④下一条微指令的形成方法常考的：**断定法（根据当前执行的微指令寻找到下一条微指令）和计数器法（类似PC）**

### 第五节 异常和中断机制

*这节会在后面第七章一起讲*

### 第六节 指令流水线

讲在前面，为什么要引入指令流水线。相信都听说过华强北的流水线运作方式吧。最明显的优点就是相较于顺序执行的吞吐量更大（单位时间内）运行相同数量的指令也更快。效率也更高。

这里就可以知道指令流水线的概念：**把指令执行过程划分为不同的阶段，占用不同的资源，就能使多条指令同时执行**。

①在流水执行的过程中，会经常遇到冲突，包括结构冲突，**数据冲突**，控制冲突。



|  | 结构相关/冲突/冒险 | 数据相关/冲突/冒险 | 控制相关/冲突/冒险 |
| --- | --- | --- | --- |
| 概念 | 多条指令在同一时刻争用同一资源 | 下一条指令会用到当前指令计算的结果 | 遇到执行转移、调用、返回导致PC中断 |
| 处理办法 | 1.单独设置数据存储器和指令存储器，使取数和取值操作在不同的存储器中进行2.暂停时钟周期 | 1.暂停时钟周期2.数据旁路技术3.编译优化 | 1.早判断，早生成2.预取转移成功和不成功两个控制流方向的目标指令3.加快和提前形成条件码4.提高转移方向的猜准率 |

  


②**五段式指令流水线（超重要）**

![[v2-3e5fc6faa036d3008f39d36abc062a41_b.jpg]]
()

顾名思义，五段分为IF(取值),ID(译码&取数),EX(执行),M(访存),WB(写回寄存器)

只有上一条指令进入ID段后，下一条指令才能开始IF段，否则会覆盖IF段锁存器的内容

考试中常见的五类指令：

**Ⅰ、运算类指令的执行过程**

IF：根据PC从指令Cache取指令至IF段的锁存器

ID：取出操作数至ID段的锁存器

EX：运算，将结果存入EX段锁存器

M：空段

WB：将运算结果写回指定的寄存器

**Ⅱ、LOAD指令执行过程**

**作用**：load指令可以完成将数据从存储器中复制到目的寄存器中，会访存

IF：根据PC从指令Cache取指令至IF段的锁存器

ID：将基址寄存器的值放到锁存器A，将偏移量的值放到lmm

EX：运算，得到有效地址

M：从数据Cache中取数并放入锁存器

WB：将运算结果写回指定的寄存器

**Ⅲ、STORE指令执行过程**

**作用：**将数据从寄存器中，复制到存储器中，会访存

IF：根据PC从指令Cache取指令至IF段的锁存器

ID：将基址寄存器的值放到锁存器A，将偏移量的值放到lmm。将要存的数放到B

EX：运算，得到有效地址。并将锁存器B的内容放到锁存器Store

M：写入数据Cache

WB：空段

**Ⅳ、条件转移指令执行过程**

IF：根据PC从指令Cache取指令至IF段的锁存器

ID：进行比较的两个数放入锁存器A，B；偏移量放入lmm

EX：运算，比较两个数

M：将目标PC值写回PC

WB：空段

**Ⅴ、无条件转移指令的执行过程**

IF：根据PC从指令Cache取指令至IF段的锁存器

ID：偏移量放入lmm

EX：将目标PC值写回PC

M：空段

WB：空段

针对条件转移指令和无条件转移指令做以下说明：写入PC的好事比EX更短，可以安排在EX段时间内完成。越**早完成就越能避免控制冲突**。当然也有在WB段修改PC值的

### 题目总结：

①流水CPU是由一系列叫做“段”的处理线路组成的。一个m段流水线稳定时的CPU的吞吐能力，与m个并行部件的CPU的吞吐能力相比**具有相同的吞吐能力**

原因是当流水线稳定后，说明已经进行了一条指令，往后每多一个时钟周期就多一条指令执行成功。

m个并行平均下来也是一个时针周期就多条指令

故具有相同的吞吐能力，但是流水线的方式，结构实现较为简单。

  


### 第七节 多处理器的基本概念（选择题）

这节的要求就是明白基本概念

①SISD（单指令流单数据流）

特点：只能并发，不能并行，每条指令处理一个指令

不是数据级并行技术



|  | SISD（单指令流单数据流） | SIMD（单指令多数据流） | MIMD（多指令多数据流） | 多处理器系统 | 多计算机系统 |
| --- | --- | --- | --- | --- | --- |
| 特点 | 不是数据级并行技术 | 是一种数据级并行技术 | 是一种线程级并行技术 | 多个处理器共享单一物理地址空间 | 每台计算机拥有私有存储器，相互独立 |
| 特征 | 一条指令处理一个数据 | 一条指令处理多个数据 | 多条指令处理多个数据 | 多个处理器+一个主存储器 | 多个处理器+多个主存储器 |

* 并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。
* 并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。

并发不是并行。并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。（你学废了吗？）

  


## 第六章 总线

### 第一节 总线的概述

![[v2-c70a08296cbc4ae215427c4595001fe0_b.jpg]]
()

* 片内总线：芯片内部的总线，是CPU芯片内部寄存器与寄存器之间，寄存器与ALU之间的公共连接线
* 系统总线：计算机系统内部功能部件（CPU、主存、I/O接口）之间相互连接的总线，可分为三类，数据总线，地址总线，控制总线
* 通信总线：计算机系统之间或计算机系统与其它系统之间的信息传送的总线



|  | 数据总线 | 地址总线 | 控制总线 |
| --- | --- | --- | --- |
| 功能 | 传输数据信息 | 传输地址信息 | 传输控制信息 |
| 大小与什么有关 | 机器字长、存储字长 | 主存地址空间大小 | 传输一个信号 |
| 方向 | 双向 | 单向 | 既有双向也有单向 |



| 总线结构 | 单总线（常用） | 双总线 | 三总线 |
| --- | --- | --- | --- |
| 内容 | 系统总线 | 主存总线、I/O总线 | 主存总线、I/O总线、DMA总线 |
| 结构 | CPU、主存、I/O设备都连接在一组总线上 | 主存总线用于CPU，主存之间的传送；I/O总线用于多个外部设备与通道之间进行传送 | 多加的一条DMA总线是用于主存访问高速外设 |
| 优点 | 结构简单，成本低，易于接入新的设备 | 将较低速的I/O设备从单总线分离出来，实现存储器总线和I/O总线分离 | 更加提高了I/O设备的性能，更快响应命令，提高系统吞吐量 |
| 缺点 | 带宽低，负载重，不支持并发传送操作 | 需要增加硬件设备 | 系统工作效率低，同一时刻只能一个总线工作 |

### 第二节 性能指标

写一些会考的性能指标，配合相应的题

### 第三节 总线定时方式



|  | 同步通信 | 异步通信 | 半同步通信 | 分离式通信 |
| --- | --- | --- | --- | --- |
| 特点 | 由统一时钟控制数据传送 | 采用应答方式，没有公共时钟的标准 | 同步、异步结合 | 充分挖掘系统总线每瞬间的潜力 |
| 优点 | 传送速度快 | 保证两个工作速度相差很大的部件之间进行传输 |  |  |
| 缺点 | 强制性同步 | 复杂，慢 |  |  |

补充：关于异步通信还分为三类：不互锁，速度最快，可靠性最差；半互锁；全互锁。速度最慢，可靠性最好。

  


## 第七章 I/O系统

### 第一节 I/O接口

简单来说，**I/O接口就是负责协调主机与外部设备之间的数据传输**。

可以这样理解就是你的电脑，怎么控制你的U盘上，做一些读写操作。U盘不是“亲儿子”啊，所以要单独给它设置接口来控制它。

CPU那如何确定要操作的是主存还是外部设备呢。这就引出了编制方式——统一编制和独立编址



|  | 统一编制 | 独立编制 |
| --- | --- | --- |
| 内容 | 把外部设备的存储当成内存进行分配，有统一的地区分配，靠不同的地址区别内存和外部设备 | 独立编制，专门为输入/输出指令设置访问端口，靠不同指令区别内存和外部设备 |
| 优点 | 1.不需要专门的指令表示访问外存2.读写控制电路简单3，程序设计灵活性高 | 1.地址译码快2.不占用主存地址空间 |
| 缺点 | 1.端口占用了主存地址空间，使主存地址空间变小2.寻址时间长（外部设备） | 1.程序设计灵活差2.指令增加，控制电路复杂 |

补充个会考的内容，关于显存VRAM（就是显示存储器）

显存是为了提高刷新图像的信号，会提前把需要显示的数据放入显存中。如今的计算机很多都有独立显存，就这可以避免，显存占用主存的空间。

显存会考的计算：

容量=分辨率×灰度级位数

带宽=分辨率×灰度级位数×帧数

  


### 第二节 主机访问I/O设备的控制方式

**一、程序查询方式**

特点：CPU与I/O串行工作，CPU不断查询I/O设备状态，直到外设准备就绪。

优点：接口设计简单，设备量少。

缺点：CPU信息传送过程中要花费很多时间用于查询和等待，而且在一段时间内只能和一台外设交换信息，效率低。

独占查询：CPU100%的时间都在查询I/O状态，完全串行。

定时查询：每隔一段时间CPU就查询I/O状态，查询的间隔内CPU可以执行其他程序。

  


**二、中断方式**

Ⅰ、程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时中断现行程序，而转去执行这些异常情况或特殊请求进行处理。处理完毕后又自动返回到现行程序的断点处，继续执行原程序。

引出几个问题：

问题一：接收到中断信号后是怎么转到执行中断程序的？

问题二：中断程序执行完后是怎么回来执行原先程序的？

问题三：假如有多个程序断源同时申请，怎么专门安排优先顺序？

问题四、如何判断是哪个设备发来的中断信号？

Ⅱ、***整个中断方式的流程（重点）***

1.中断请求

*“先说明开中断和关中断的作用，关中断保证原子操作，不会被打断，标志位IF=1为开中断（允许中断）”*

CPU在统一时刻每条指令执行阶段结束前向接口发出中断查询信号，获取I/O的中断请求，也就是说，CPU响应中断的时间是在每条指令执行阶段的结束时刻。

如何判断是哪个设备发来的中断信号？

会存在一个中断请求标记寄存器，里面不同位代表不同的设备中断。状态位为1的话，代表处理中断申请。

CPU响应中断必须满足以下3个条件：

①中断源有中断请求。

②CPU允许中断即断开中断。

③一条指令执行完毕，且没有更紧迫的任务。

  


2.中断响应

假如有多个程序断源同时申请，怎么专门安排优先顺序？

有两种处理办法：

①硬件实现硬件排队器

②软件实现查询程序

中断的优先级：

硬件故障中断>软件中断

非屏蔽中断>可屏蔽中断

DMA请求>I/O设备传送的中断请求

有再补充

3.中断处理

接收到中断信号后是怎么转到执行中断程序的？

这时候就需要中断隐指令：保存原程序的PC值，并让PC指向中断程序的第一条。

**中断隐指令的任务：**

**①关中断。在中断服务程序中，为保护中断现场不会再被新的中断打断，就必须关中断**

**②保存断点。保证“回得来”**

**③引出中断服务。将中断服务程序入口地址传送给程序计数器**

引出中断服务，如何将中断传给PC？

通过硬件向量法，将硬件（中断向量地址形成部件）产生向量地址，再由向量地址找到入口地址。

中断处理过程—硬件向量法。为什么要用向量地址去寻找中断的入口，而不是直接去寻找中断入口？

1.若是通过中断向量地址形成部件直接去入口地址的话，会造成中断程序有时候长短不一，就要频繁修改中断向量地址形成部件。

2.若是先通过向量地址，在内存中找到中断地址的话，只需修改内存的地址就可以。

![[v2-4a84ec2d9a1d077ae2fa52a9305d6cd0_b.jpg]]
()

**中断服务程序的任务**

**①保护现场。保存通用寄存器和状态寄存器的内容。**

**②中断服务。主体部分。例如将需要打印的字符传送到打印机的缓冲存储器中。**

**③恢复现场。通过出栈或取值把之前保存的信息传送回寄存器中。**

**④中断返回。通过中断返回指令回到原程序断点处。**

  


总结：中断处理过程=中断隐指令+中断服务程序

![[v2-02648200b81d1278cb12f6cb504bbd5f_b.jpg]]
()

中断流程Ⅲ、单重中断和多重中断

单重中断：执行中断服务程序时不响应新的中断请求。

多重中断：又称中断嵌套，执行中断服务程序时可响应新的中断请求。

对于多重中断有中断屏蔽技术，在中断服务开启前打开中断指令。优先级别高的中断源有权中断优先级别低的中断源。

这时候就要设置一个屏蔽触发器，1表示屏蔽该中断请求，0表示正常申请，所有屏蔽触发器构成一个屏蔽寄存器，屏蔽寄存器里面内容就是屏蔽字。

有以下几个说明

①每个中断源至少有一个1（对自身中断源）

②1越多，优先级越高

![[v2-8aa734eff62a85a1c978bc11074b031f_b.jpg]]
()

看懂这个例题就够了**三、DMA方式**

DMA的特点：

1、内存既可以被CPU访问也可以被DMA控制器访问，CPU和DMA控制器会竞争总线的使用权，因而需要仲裁机制。

2、外部设备与内存之间的整个数据交换过程全部在DMA控制器的控制下完成，CPU能够与外部设备并行工作，大大提高了效率。

3、在DMA方式开始之前CPU要对DMA控制器进行初始化，在DMA方式结束之后，CPU要申请中断，对内存缓冲区进行后处理。

DMA的处理方式：

1.预处理：CPU完成寄存器初值设置等准备工作。

2.数据传输：CPU继续执行主程序，DMA控制器完成数据传送

3.后处理：CPU执行中断服务程序做DMA结束处理

DMA的传送方式：

1.停止CPU访存：需要传送数据时，停止CPU访存，总线控制器交给DMA控制器。

2.周期挪用方式：当I/O接口没有DMA请求时，CPU按程序要求访问内存；一旦I/P接口有DMA请求，则I/O接口挪用一个或几个周期。缺点是：数据输入或输出过程中实际占用了CPU时间。

3.交替访存方式：CPU与DMA控制器交替访问内存。不需要总线使用权的申请、建立和归还过程。

效率高，但实现起来有困难，基本上不被使用。

* DMA与中断方式的差别



|  | 中断 | DMA |
| --- | --- | --- |
| 数据传送 | 程序控制 | 硬件控制—DMA控制器。CPU只需进行预处理和后处理 |
| 中断请求 | 传送数据 | 向CPU报告传输结束 |
| 响应 | 指令执行周期结束后响应中断 | 每个机器周期结束都可，即总线空闲即可 |
|  |  |  |
| 适用场景 | CPU控制，低速设备 | DMA控制器控制，高速设备 |
| 优先级 | 低于DMA | 高于中断 |
| 工作方式 | CPU与外设并行，传送与主程序串行 | CPU与外设并行，传送与主程序并行 |
| 请求内容 | 请求的是CPU处理时间 | 请求的是总线使用权 |

* 中断的分类：

![[v2-9e0782f89fa170d9a75f607f4612b901_b.jpg]]
()

中断分类



